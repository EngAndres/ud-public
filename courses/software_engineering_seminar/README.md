# Software Engineering Seminar

 This course is designed to *introduce undergraduate students* to the *fundamental concepts* of **software engineering**, including *requirements engineering*, **agile methodologies**, and **collaborative development practices**.

 The main focus of the course is on *software testing engineering*. Students will learn about **testing principles**, **test design techniques**, and **automation tools** to ensure software quality. The course covers **unit testing**, **integration testing**, **system testing**, and **test-driven development (TDD)** within *agile frameworks*.

 Classes will include *lectures*, *practical exercises*, and a **team project**. By the end of the course, students will be able to **define requirements**, apply *agile practices*, and implement effective **testing strategies** in real-world software projects.

- [Software Engineering Seminar](#software-engineering-seminar)
  - [Goals](#goals)
  - [Pre-requisites](#pre-requisites)
  - [Syllabus](#syllabus)
  - [Grading](#grading)
  - [Tasks](#tasks)
  - [Rules](#rules)
  - [Code of Conduct](#code-of-conduct)
  - [Bibliography](#bibliography)

## Goals

The *main goal* of this course is to provide students with a solid understanding of **software engineering fundamentals**, with a strong emphasis on *software testing*.

By the end of the course, you should be able to:
- **Elicit and document requirements** for software projects.
- Apply *agile methodologies* and collaborative practices in development teams.
- Understand and implement **testing principles** and **test design techniques**.
- Develop and execute **unit**, **integration**, and **system tests**.
- Use **automation tools** and apply **test-driven development (TDD)**.
- Evaluate and improve software quality through effective testing strategies.

## Pre-requisites

This is an advanced course, so you must have some knowledge of:
- *Programming* in *Java*, *Python*, or *C++*.
- *Foundations* of *Object-Oriented Programming*.
- Basic concepts of **UML** and *Class Diagrams*.
- Basic usage of *Git* and `GitHub`.
- Basic concepts of `data systems` and the *relational model*.
- Use of *IDEs* such as *VS Code*, Eclipse, or PyCharm.

## Syllabus

Below is a distribution of topics and sessions. Each topic has a link to the corresponding _slides_ or _definition_.

| **Period**   | **Topic**                           | **Time**      |
|--------------|-------------------------------------|---------------|
|              | [Software Engineering Introduction](./slides/SoftwareEngineeringIntroduction.pdf)   | 3 sessions    |
|              | Agile Methodologies                 | 2 sessions    |
|              | [Project Management](./slides/SoftwareProjectManagement.pdf)                  | 2 sessions    |
|              | [Requirements Engineering](./slides/RequirementsEngineering.pdf)            | 3 sessions    |
|              | System Analysis & Design            | 2 sessions    |
|              | [Software Architectures Fundamentals](./slides/SoftwareArchitecturesIntroduction.pdf) | 2 sessions    |
|              | [Testing Engineering Fundamentals](./slides/TestingEngineeringFundamentals.pdf)    | 2 sessions    |
|              | Catch Up --- Course Project         | 2 sessions    |
| **Period II**| Unit Testing                        | 4 sessions    |
|              | Integration Testing                 | 2 sessions    |
|              | Acceptance Testing                  | 3 sessions    |
|              | System Performance Testing          | 2 sessions    |
|              | Final Test                          | 1 session     |
| **Period III**| Project Dissertation               | 2 sessions    |

## Grading

As follows there is a simple distribution of percentage of grades:


| Period    | Item                   | Percentage |
| --------- | ---------------------- | ---------- |
| Period I  | Assignments            |  5%        |
|           | Workshops              | 20%        |
|           | Partial Test 1         | 10%        |
| Period II | Assignments            |  5%        |
|           | Workshops              | 20%        |
|           | Final Test             | 10%        |
| Period III| Paper + Poster         | 5%         |
|           | Report + Implementation| 15%        |
|           | Presentation           | 10%        |


## Tasks

Below is the list of tasks for the course. Each task should be written as one paragraph containing between **200** and **300 words**. Please be mindful of the deadlines.

| **Deadline**   | **Task ID** | **Task Description**                                                                                                                                           |
| -------------- | ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| September 20th     | T1          | How do the principles of requirements engineering contribute to the success of software projects, and what techniques can be used to elicit and document requirements effectively? |
| September 30th      | T2          | What are the main agile methodologies in software engineering, and how do they foster collaboration and adaptability in development teams?                        |
| October 11st     | T3          | How can project management practices be integrated into software engineering to ensure timely delivery and high-quality outcomes?                                 |
| October 21st     | T4          | In what ways do software architecture fundamentals influence the design and scalability of complex software systems?                                              |
| November 1st        | T5          | How can testing engineering fundamentals be applied to improve software quality, and what are the key principles of effective test design?                        |
| November 11st    | T6          | What are the differences between unit, integration, and system testing, and how do they contribute to comprehensive software validation?                          |
| November 22nd       | T7          | How can automation tools and test-driven development (TDD) be leveraged to streamline the software testing process and enhance reliability?                       |
| December 2nd       | T8          | What are the best practices for presenting and documenting software engineering projects, and how can these practices improve communication and project outcomes? |


## Rules

Don't hate the player, hate the game:

- *All assignments* must be submitted *handwritten* on **time** and in **English**. Grammar and spelling will **not** be evaluated.
- *Copying* and *pasting* from the internet are **forbidden**. Please **develop** your *own ideas and solutions*.
- Class attendance is **not mandatory**. If you **miss** classes, you must *study independently*.
- No cell phones, no smartwatches, no WhatsApp, no Tinder, no *smart-anything*. **Just you and your brain**. *Pay attention in class*.
- *Communication* with me must be via **email** or **Slack**. I will **not** answer any questions via *WhatsApp*.

## Code of Conduct

- *Always* be **respectful** to your *classmates* and to me. You must be **kind** to everyone inside (*and outside*) the classroom.
- There is *no* best *programming language*, *tool*, or *technology*. There are only **better** or **worse** solutions.
- You must be **honest** with your work. If you *don't know something*, just **ask** me. I will be *glad* to help you.
- You must be **responsible** with your work. If you don't submit **on time**, please *don't complain*.
- You must not be **disruptive** or **negatively affect** the **classroom environment**. If you do, I will *ask you* to **leave** the classroom.

## Bibliography

Recommended bibliography:

- **Software Engineering**, by *Ian Sommerville*.
- **Software Engineering at Google**, by *Titus Winters, Tom Manshreck, and Hyrum Wright*.
- **The Pragmatic Programmer**, by *Andrew Hunt and David Thomas*.
- **Clean Code: A Handbook of Agile Software Craftsmanship**, by *Robert C. Martin*.
- **Refactoring: Improving the Design of Existing Code**, by *Martin Fowler*.
- **Test-Driven Development: By Example**, by *Kent Beck*.
- **Agile Estimating and Planning**, by *Mike Cohn*.
- **Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment**, by *Jez Humble and David Farley*.
- **Agile Testing: A Practical Guide for Testers and Agile Teams**, by *Lisa Crispin and Janet Gregory*.
- **Specification by Example: How Successful Teams Deliver the Right Software**, by *Gojko Adzic*.
- **Domain-Driven Design: Tackling Complexity in the Heart of Software**, by *Eric Evans*.
- **Patterns of Enterprise Application Architecture**, by *Martin Fowler*.
- **Design Patterns: Elements of Reusable Object-Oriented Software**, by *Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides*.